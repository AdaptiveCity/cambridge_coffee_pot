"""
MQTT links for SensorHub and RemoteSensors using gmqtt

link = Link(settings) - instantiate object. settings = application settings e.g. "LOG_LEVEL"

await link.start(server_settings) - CONNECT to host, server_settings e.g. "host"

await link.finish() - cleanup, e.g. DISCONNECT from host

await link.put(sensor_id, event) - SENDS message to host

await link.subscribe(subscription_settings) - requests SUBSCRIPTION from host, settings { topic: }

await link.get() - async GETS next message from host

"""

import asyncio
import simplejson as json
from simplejson.errors import JSONDecodeError

from gmqtt import Client as MQTTClient
from gmqtt.mqtt.constants import MQTTv311

# gmqtt also compatibility with uvloop
#import uvloop
#asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

class LinkGMQTT(object):

    def __init__(self, settings=None):
        print("LinkGMQTT __init__()")
        self.settings = settings
        self.client = MQTTClient(None) # None => autogenerated client id
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.on_disconnect = self.on_disconnect
        self.client.on_subscribe = self.on_subscribe

        self.subscription_queue = asyncio.Queue()
        print("LinkGMQTT __init__ completed")


    async def start(self, server_settings):
        """
        Connects to broker
        """
        print('LinkGMQTT.start() connecting as user {}'.format(server_settings["user"]))
        self.client.set_auth_credentials(server_settings["user"], server_settings["password"])
        try:
            await self.client.connect(server_settings["host"],keepalive=60,version=MQTTv311)
        except Exception as e:
            print("LinkGMQTT connect exception: {}".format(e))
            return
        print('LinkGMQTT.start() connected {}'.format(server_settings["host"]))


    async def put(self, sensor_id, event):
        """
        Sends sensor_id/event to MQTT broker.
        sensor_id is string, used as MQTT topic
        event is dictionary which will be converted to bytes for MQTT message
        """
        #print('LinkGMQTT.put() sending {}'.format(sensor_id))

        message = json.dumps(event)
        self.client.publish(sensor_id, message, qos=0)

        print("LinkGMQTT.put() published {} {}".format(sensor_id,message))


    async def subscribe(self, subscribe_settings):
        """
        Subscribes to sensor events.
        """
        try:
            self.client.subscribe(subscribe_settings["topic"], qos=0)
        except Exception as e:
            print("LinkGMQTT subscribe exception: {}".format(e))
            return
        print("LinkGMQTT.subscribed() {}".format(subscribe_settings["topic"]))


    async def get(self):
        print("LinkGMQTT get requested from client, awaiting queue")
        message = await self.subscription_queue.get()
        print("LinkGMQTT get returned from queue")

        return message


    def on_connect(self, client, flags, rc, properties):
        print('LinkGMQTT Connected')


    def on_message(self, client, topic, payload, qos, properties):
        print('LinkGMQTT RECV MSG:', topic, payload)
        message = payload.decode('utf-8')

        message_dict = {}
        try:
            message_dict = json.loads(message)
        except JSONDecodeError:
            message_dict["message"] = message
            print("remote_sensors() json msg error: {} => {}".format(topic,message))

        message_dict["topic"] = topic

        self.subscription_queue.put_nowait(message_dict)


    def on_disconnect(self, client, packet, exc=None):
        print('LinkGMQTT Disconnected')


    def on_subscribe(self, client, mid, qos, properties):
        print('LinkGMQTT Subscribed')


    async def finish(self):
        await self.client.disconnect()

